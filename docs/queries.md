# Документація складних запитів

У цьому документі описані аналітичні SQL-запити, що використовуються в системі для генерації звітів. Запити виконуються через `prisma.$queryRaw`, що дозволяє використовувати повний функціонал SQL (агрегації, складні об'єднання, фільтрацію груп).

---

## Запит 1: Топ найактивніших читачів

### Бізнес-питання

**"Хто є нашими найактивнішими читачами, скільки книг вони брали та яка їхня історія штрафів?"**

Цей звіт дозволяє бібліотекарям ідентифікувати найактивніших користувачів для заохочення, а також моніторити фінансову дисципліну читачів (наявність штрафів).

### SQL-запит

```sql
SELECT
  m.name,
  m.surname,
  m.phone_number,
  COUNT(l.loan_id)::int as total_loans,
  COUNT(f.fine_id)::int as total_fines,
  COALESCE(SUM(f.amount), 0) as total_fine_amount
FROM "Member" m
LEFT JOIN "Loan" l ON m.member_id = l.member_id
LEFT JOIN "Fine" f ON l.loan_id = f.loan_id
GROUP BY m.member_id, m.name, m.surname, m.phone_number
HAVING COUNT(l.loan_id) > 0
ORDER BY total_loans DESC
LIMIT 5;
```

### Пояснення логіки

1.  **LEFT JOIN:** Використовується для з'єднання таблиць `Member`, `Loan` та `Fine`.

    - `Member -> Loan`: Щоб отримати історію видач.
    - `Loan -> Fine`: Щоб перевірити наявність штрафів для кожної видачі.
    - Використання `LEFT JOIN` гарантує, що ми побачимо читача, навіть якщо у нього немає жодного штрафу (у такому випадку дані про штрафи будуть `NULL`).

2.  **Агрегатні функції:**

    - `COUNT(l.loan_id)`: Підраховує загальну кількість книг, які брав читач.
    - `COUNT(f.fine_id)`: Підраховує кількість інцидентів зі штрафами.
    - `SUM(f.amount)`: Підсумовує загальну суму штрафів.

3.  **COALESCE:**

    - `COALESCE(SUM(f.amount), 0)` перетворює можливий `NULL` (якщо штрафів немає) на `0` для коректного відображення в інтерфейсі.

4.  **HAVING:**
    - Фільтр `HAVING COUNT(l.loan_id) > 0` відсіює користувачів, які зареєструвалися, але ще не користувалися послугами бібліотеки.

### Приклад виводу

| name  | surname   | phone_number | total_loans | total_fines | total_fine_amount |
| :---- | :-------- | :----------- | :---------- | :---------- | :---------------- |
| Іван  | Петренко  | 0501234567   | 15          | 2           | 150.00            |
| Марія | Коваленко | 0679876543   | 12          | 0           | 0.00              |
| Петро | Сидоренко | 0631112233   | 8           | 1           | 50.00             |
| Олена | Бойко     | 0975554433   | 5           | 0           | 0.00              |

## Запит 2: Статистика популярності категорій

### Бізнес-питання

**"Які літературні жанри (категорії) користуються найбільшим попитом серед читачів?"**

Цей аналіз допомагає адміністрації бібліотеки планувати закупівлю нових книг, орієнтуючись на реальний попит, а не на припущення.

### SQL-запит

```sql
SELECT
  c.category_name as category,
  COUNT(l.loan_id)::int as loan_count
FROM "Category" c
JOIN "BookCategory" bc ON c.category_id = bc.category_id
JOIN "Book" b ON bc.book_id = b.book_id
JOIN "Loan" l ON b.book_id = l.book_id
GROUP BY c.category_id, c.category_name
ORDER BY loan_count DESC;
```

### Пояснення логіки

1.  **Багатотабличний JOIN (4 таблиці):**

    - Запит будує ланцюжок від категорії до факту видачі: `Category` → `BookCategory` → `Book` → `Loan`.
    - Використовується `INNER JOIN`, тому до звіту потрапляють тільки ті категорії, книги з яких реально видавалися.

2.  **Групування (GROUP BY):**

    - Дані згортаються по `category_id` та `category_name`.

3.  **Сортування (ORDER BY):**
    - Результати впорядковані за спаданням (`DESC`) кількості видач (`loan_count`), щоб найпопулярніші жанри були зверху.

### Приклад виводу

| category           | loan_count |
| :----------------- | :--------- |
| Фантастика         | 42         |
| Наукова література | 28         |
| Класика            | 15         |
| Детективи          | 10         |
| Поезія             | 3          |
